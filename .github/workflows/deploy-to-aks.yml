
# This workflow defines the project's Continuous Integration and Continuous Deployment (CI/CD) pipeline.
name: Build and Deploy to AKS

# This workflow is configured to run under two conditions:
# 1. On every `push` event to the `main` branch.
# 2. Manually, via the `workflow_dispatch` event (using the 'Run workflow' button in the GitHub Actions UI).
on:
  push:
    branches:
      - main
  workflow_dispatch: {}

# Environment variables available to all jobs and steps in the workflow.
# This makes the script cleaner and easier to manage.
env:
  AKS_CLUSTER_NAME: aks-taskmanager-testing
  RESOURCE_GROUP_NAME: rg-taskmanager-testing
  IMAGE_NAME: taskmanager-app

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Check out the repository code
      # This action downloads the source code into the runner environment.
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Log in to Azure
      # This uses the Service Principal credentials stored in the AZURE_CREDENTIALS GitHub secret
      # to authenticate with Azure. OIDC is used for a secure, passwordless login.
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Step 3: Log in to Azure Container Registry (ACR)
      # This authenticates the Docker client using the ACR admin credentials.
      - name: ACR Login
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      # Step 4: Build and push the Docker image to ACR
      # This step builds the Dockerfile.app and pushes the resulting image to our ACR.
      # We tag the image with the unique Git commit SHA for versioning and traceability.
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Dockerfile.app
          push: true
          tags: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

      # Step 5: Update Kubernetes manifests with dynamic values
      # Before applying the manifests, we need to inject real, dynamic values into them.
      - name: Update Kubernetes manifests
        run: |
          # Use the `sed` command with a `#` delimiter for robustness.
          sed -i 's#YOUR_ACR_LOGIN_SERVER/taskmanager-app:latest#${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ github.sha }}#' k8s/deployment.yaml

          # For the secret manifest, we must base64-encode our secret values, as required by Kubernetes.
          # We use the `-w 0` flag for `base64` to prevent line wrapping, which breaks the `sed` command.
          DB_URL=$(echo -n "jdbc:postgresql://${{ secrets.DB_HOST }}:5432/taskmanager")
          DB_URL_B64=$(echo -n "$DB_URL" | base64 -w 0)
          DB_USER_B64=$(echo -n "pgadmin" | base64 -w 0)
          DB_PASSWORD_B64=$(echo -n "${{ secrets.DB_PASSWORD }}" | base64 -w 0)
          sed -i "s#db-url: .*#db-url: ${DB_URL_B64}#" k8s/secret.yaml
          sed -i "s#db-user: .*#db-user: ${DB_USER_B64}#" k8s/secret.yaml
          sed -i "s#db-password: .*#db-password: ${DB_PASSWORD_B64}#" k8s/secret.yaml

      # Step 6: Set up kubectl context
      # This action logs into our specific AKS cluster and configures the `kubectl` command-line tool
      # to communicate with it. From this point on, `kubectl` commands will target our cluster.
      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.RESOURCE_GROUP_NAME }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      # Step 7: Create or update the image pull secret in Kubernetes
      # This uses the ACR credentials to create a secret that Pods can use to authenticate with ACR.
      # We use --dry-run to check if it exists, and create or patch accordingly.
      - name: Create/Update Image Pull Secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --docker-email=no-reply@example.com \
            --dry-run=client -o yaml | kubectl apply -f -

      # Step 8: Deploy to AKS
      # This is the final deployment step. `kubectl apply -f k8s/` tells Kubernetes to take all the .yaml
      # files in the `k8s` directory and create or update the resources in the cluster to match the definitions.
      - name: Deploy to AKS
        run: |
          kubectl apply -f k8s/
